package neurax;

import java.io.*;
import java.util.Date;
import java.util.Scanner;

/**
 * Class desired to communicate with other enviroment - louading files, std I/O
 * with GTP v2 support
 *
 * @author ancrax
 */
public class GameInterface {

    private static final int GTP_VERSION = 2; //by the second version of draft
    /**
     * generated by http://www.netsubstance.com/ , thanks
     */
    private static final String ENGINE_NAME = "Neurax";
    private static final String ENGINE_VERSION = "1.0";
    /**
     * indexes of boardstate notes
     */
    public static final int PLAYER_BLACK_ID = 1;
    public static final int PLAYER_WHITE_ID = 2;
    public static final int FREE_NODE_ID = 0;
    //boardstate notes
    public static final char FREE_NODE_CHAR = '.';
    public static final char PLAYER_BLACK_CHAR = 'X';
    public static final char PLAYER_WHITE_CHAR = 'O';
    /**
     * axis descs
     */
    public static final String COLUMN_CHARS_GTP = "ABCDEFGHJKLMNOPQRSTUVWXYZ"; //*-I
    public static final String COLUMN_CHARS_SGF = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    //name of file with neural netowr configuration
    public static final String ENGINE_CONFIG_FILE = "engineConfig.bin";
    public static boolean DEBUG = false;
    private String[] implementedCommands = new String[17];
    public GameController controller;

    /**
     * std construct
     */
    public GameInterface() {
        //create controller instance
        controller = new GameController();
        try {
            //try load networks config from file (rewrite instance)
            controller = new GameController(loadNetworksConfig());
        }
        catch (IOException ex) {
            //nop, instance allready createdf
        }
        catch (ClassNotFoundException ex) {
            //nop, instance allready createdf
        }

        //set known commands for GTP - by GTP v2 specification
        //required commands
        implementedCommands[0] = "protocol_version";
        implementedCommands[1] = "name";
        implementedCommands[2] = "version";
        implementedCommands[3] = "known_command";
        implementedCommands[4] = "list_commands";
        implementedCommands[5] = "quit";
        implementedCommands[6] = "boardsize";
        implementedCommands[7] = "clear_board";
        implementedCommands[8] = "komi";
        implementedCommands[9] = "play";
        implementedCommands[10] = "genmove";
        implementedCommands[11] = "showboard";
        //optional commands
        implementedCommands[12] = "list_stones";
        implementedCommands[13] = "final_score";
        //own commands
        implementedCommands[14] = "neurax_learn_samples"; //@param 1 directory
        implementedCommands[15] = "neurax_save";
        implementedCommands[16] = "neurax_learned_count";
    }

    /**
     *
     * @param args if this param is not null, set DEBUG mode
     */
    public static void main(String[] args) {

        if (args.length != 0) {
            //switch on debug mode
            GameInterface.DEBUG = true;
        }

        //init stuff
        GameInterface interf = new GameInterface();

        //init helpers variables
        Move move;
        int cmdId;
        String command;
        String arguments[];
        Scanner sc = new Scanner(System.in);

        //infinity read from std in
        while (true) {
            command = sc.nextLine().trim();

            cmdId = 0;
            //sub command id from start (@see GTP v2 segment 2.5)
            while (cmdId < command.length()) {
                if (!Character.isDigit(command.charAt(cmdId))) {
                    break;
                }
                cmdId++;
            }

            //parse arguments
            arguments = command.substring(cmdId).trim().split(" ");
            command = arguments[0];

            try {
                //it is java 6 compatibile - switch does not supprot String jet
                //decide command to run in this app
                if (command.equals("quit")) {
                    GameInterface.succesOut(" ");
                    return;
                }
                else if (command.equals("protocol_version")) {
                    GameInterface.succesOut(String.valueOf(interf.getGtpVersion()));
                }
                else if (command.equals("name")) {
                    GameInterface.succesOut(interf.getEngineName());
                }
                else if (command.equals("version")) {
                    GameInterface.succesOut(interf.getEngineVersion());
                }
                else if (command.equals("list_commands")) {
                    GameInterface.succesOut(interf.getListOfCommands());
                }
                else if (command.equals("boardsize")) {
                    interf.controller.setBoardSize(Integer.parseInt(arguments[1]));
                    GameInterface.succesOut(" ");
                }
                else if (command.equals("known_command")) {
                    if (interf.isCommandKnown(arguments[1])) {
                        GameInterface.succesOut("true");
                    }
                    else {
                        GameInterface.succesOut("false");
                    }
                }
                else if (command.equals("clear_board")) {
                    interf.controller.actionClearBoard();
                    GameInterface.succesOut(" ");
                }
                else if (command.equals("komi")) {
                    interf.controller.setKomi(Double.parseDouble(arguments[1]));
                    GameInterface.succesOut(" ");
                }
                else if (command.equals("play")) {
                    try {
                        move = Helpers.getParsedMove(arguments[1]
                                + " " + arguments[2]);
                    }
                    catch (Exception ex) {
                        GameInterface.stdOut("#" + ex);
                        GameInterface.failOut("illegal move");
                        continue;
                    }
                    if (!move.isPassed()) {
                        interf.controller.actionSetStone(move);
                    }
                    GameInterface.succesOut(" ");
                }
                else if (command.equals("showboard")) {
                    GameInterface.succesOut(interf.showBoard());
                }
                else if (command.equals("genmove")) {
                    GameInterface.succesOut(interf.controller.actionGenerateMove(
                            Helpers.parseColor(arguments[1])));
                }
                else if (command.equals("list_stones")) {
                    GameInterface.succesOut(interf.controller.listStones(
                            Helpers.parseColor(arguments[1])));
                }
                else if (command.equals("final_score")) {
                    GameInterface.succesOut(Helpers.parseScoreFromArray(
                            interf.controller.getScores()));
                }
                else if (command.equals("neurax_learn_samples")) {
                    GameInterface.succesOut("learned "
                            + interf.loadSamples(arguments[1]) + " samples");
                }
                else if (command.equals("neurax_save")) {
                    interf.saveNetworksConfig();
                }
                else if (command.equals("neurax_learned_count")) {
                    GameInterface.succesOut(" " + interf.controller.getEngine().
                            getLearnedSamplesCount());
                }
                else {
                    GameInterface.failOut("unknown command");
                }
            }
            catch (ArrayIndexOutOfBoundsException e) {
                GameInterface.stdOut("# " + e);
                GameInterface.failOut("wrong count of params");
                e.printStackTrace();
                GameInterface.succesOut(" ");
                //recovery state to can gtp protocol continue
            }
            catch (Exception e) {
                //catch all - app should (never) fall down :D
                GameInterface.stdOut("# unexpect error");
                //Interface.stdOut("# " + e);
                e.printStackTrace();
                GameInterface.succesOut(" ");
                //recovery state to can gtp protocol continue
            }

        }
    }

    /**
     * GTP required staff
     *
     * @return String
     */
    public String getEngineName() {
        return GameInterface.ENGINE_NAME;
    }

    /**
     * GTP required stuff
     *
     * @return String
     */
    public String getEngineVersion() {
        return GameInterface.ENGINE_VERSION;
    }

    /**
     * GTP required suff
     *
     * @return int
     */
    public int getGtpVersion() {
        return GameInterface.GTP_VERSION;
    }

    /**
     * GTP stuff
     *
     * @return String
     */
    public String getListOfCommands() {
        StringBuilder toReturn = new StringBuilder();
        for (String command : implementedCommands) {
            if (command != null) {
                toReturn.append(command + "\n");
            }
        }
        return toReturn.toString();
    }

    /**
     * GTP stuff
     *
     * @param command
     * @return boolean
     */
    public boolean isCommandKnown(String command) {
        for (String knownCommand : implementedCommands) {
            if (knownCommand.equals(command)) {
                return true;
            }
        }
        return false;
    }

    /**
     * load all files from directory directory. try parse it and serve to next
     * app layer up to Engine object
     *
     * @param directory
     * @return checksum - slould be not 0 if there was any SGF example
     */
    public int loadSamples(String directory) {
        int learnedCount = 0;
        //save names of files where parsing fails
        StringBuilder wrongFiles = new StringBuilder();

        File folder = new File(directory);
        //for each file in folder
        for (File fileEntry : folder.listFiles()) {
            if (fileEntry.isFile()) {
                try {
                    //handle parsed file
                    this.controller.learnSamples(
                            Helpers.parseSamples(new FileInputStream(fileEntry)));
                    learnedCount++;
                }
                catch (FileNotFoundException ex) {
                    GameInterface.stdOut("File(s) not found");
                }
                catch (Exception ex) {
                    System.err.println("possible broken file:" + fileEntry.
                            getName());
                    wrongFiles.append(fileEntry.getName() + "\n");
                }

                //saving after 50 learned files
                if (learnedCount % 50 == 0) {
                    try {
                        this.saveNetworksConfig();
                    }
                    catch (IOException e) {
                        //nop
                    }
                    Date d = new Date();
                    System.out.println("saved at:" + d.toString());
                }
            }
        }

        System.out.println(wrongFiles);
        return learnedCount;
    }

    /**
     * shortcut to print to std out
     *
     * @param out
     */
    public static void stdOut(String out) {
        System.out.println(out);
    }

    /**
     * print succes out by the GTP convenction
     *
     * @param out
     */
    public static void succesOut(String out) {
        GameInterface.stdOut("= " + out + "\n");
    }

    /**
     * print failed out by the GTP convenction
     *
     * @param out
     */
    public static void failOut(String out) {
        GameInterface.stdOut("? " + out + "\n");
    }

    /**
     * return board state as String. by the GTP specification it is recommended
     * only for testing purposes
     *
     * @return String
     */
    private String showBoard() {
        StringBuilder board = new StringBuilder("\n");

        //print x axis
        board.append(Helpers.getColumnAxis(controller.getBoardSize()));

        int rowIndex = 0;
        board.append('\n');
        for (int[] column : controller.getBoardState()) {
            board.append(Helpers.getRowIndex(rowIndex));

            for (int row : column) {
                if (row == GameInterface.FREE_NODE_ID) {
                    board.append(" " + GameInterface.FREE_NODE_CHAR);
                }
                else if (row == GameInterface.PLAYER_BLACK_ID) {
                    board.append(" " + GameInterface.PLAYER_BLACK_CHAR);
                }
                else if (row == GameInterface.PLAYER_WHITE_ID) {
                    board.append(" " + GameInterface.PLAYER_WHITE_CHAR);
                }
                else {
                    board.append(row);
                }
            }

            board.append(" " + Helpers.getRowIndex(rowIndex++) + '\n');
        }

        //print x axis
        board.append(Helpers.getColumnAxis(controller.getBoardSize()));

        return board.toString();
    }

    /**
     * try to save network configuration to config file
     *
     * @throws IOException
     */
    private void saveNetworksConfig() throws IOException {
        File config = new File(GameInterface.ENGINE_CONFIG_FILE);
        FileOutputStream saveFile;

        try {
            saveFile = new FileOutputStream(config);
        }
        catch (FileNotFoundException ex) {
            config.createNewFile();
            saveFile = new FileOutputStream(config);
        }
        ObjectOutputStream save = new ObjectOutputStream(saveFile);

        save.writeObject(controller.getEngine());
        save.close();
        saveFile.close();

        //inform about success
        GameInterface.succesOut("Successfully saved in file "
                + GameInterface.ENGINE_CONFIG_FILE);
    }

    /**
     * try to load networks config from file
     *
     * @return Engine instance
     * @throws IOException
     * @throws ClassNotFoundException
     */
    private static Engine loadNetworksConfig()
            throws IOException, ClassNotFoundException {

        File config = new File(GameInterface.ENGINE_CONFIG_FILE);
        FileInputStream saveFile = new FileInputStream(config);
        ObjectInputStream save = new ObjectInputStream(saveFile);

        //get instance form file
        Engine engine = (Engine) save.readObject();

        save.close();
        saveFile.close();

        if (GameInterface.DEBUG) {
            //inform about success
            GameInterface.succesOut("Successfully load from file "
                    + GameInterface.ENGINE_CONFIG_FILE);
        }
        return engine;
    }
}
